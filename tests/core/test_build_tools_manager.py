import pytest
import os
import shutil
from pathlib import Path  # For more robust path operations
from core.build_tools_manager import run_gpt_engineer, run_opendevin_debug_loop

TEST_OUTPUT_BASE_DIR = Path("tests/temp_generated_mvps")


@pytest.fixture(scope="function", autouse=True)
def manage_test_output_dir():
    """Creates and cleans up the test output directory for each test function."""
    # Clean up before test if directory somehow exists
    if TEST_OUTPUT_BASE_DIR.exists():
        shutil.rmtree(TEST_OUTPUT_BASE_DIR)
    TEST_OUTPUT_BASE_DIR.mkdir(parents=True, exist_ok=True)

    yield  # Test runs here

    # Clean up after tests by removing the temp directory
    if TEST_OUTPUT_BASE_DIR.exists():
        shutil.rmtree(TEST_OUTPUT_BASE_DIR)


def test_run_gpt_engineer_success():
    idea_details = {"name": "Test App", "description": "A cool test application."}
    output_path = TEST_OUTPUT_BASE_DIR / "test_app_gpt"

    success = run_gpt_engineer(idea_details, str(output_path))
    assert success
    assert output_path.exists()

    readme_path = output_path / "README.md"
    app_py_path = output_path / "app.py"

    assert readme_path.exists()
    assert app_py_path.exists()

    with open(readme_path, "r", encoding="utf-8") as f:
        content = f.read()
        assert "Project: Test App" in content
        assert "A cool test application." in content
        assert "Generated by a mock GPT-Engineer." in content

    with open(app_py_path, "r", encoding="utf-8") as f:
        content = f.read()
        assert "# Main application file for Test App" in content
        assert "print('Hello from Test App!')" in content


def test_run_gpt_engineer_missing_details_name():
    idea_details = {"description": "Only description"}  # Missing name
    output_path = TEST_OUTPUT_BASE_DIR / "test_app_gpt_fail_name"
    success = run_gpt_engineer(idea_details, str(output_path))
    assert not success
    # Directory might be created before check, but files shouldn't
    # The current implementation creates dir then checks, so dir might exist.
    # For stricter test, check if output_path is empty or not created based on impl.
    # Based on current run_gpt_engineer, it returns False *before* creating dir
    # if details are missing.
    assert not output_path.exists()


def test_run_gpt_engineer_missing_details_description():
    idea_details = {"name": "Only Name"}  # Missing description
    output_path = TEST_OUTPUT_BASE_DIR / "test_app_gpt_fail_desc"
    success = run_gpt_engineer(idea_details, str(output_path))
    assert not success
    assert not output_path.exists()


def test_run_opendevin_debug_loop_success():
    project_name = "test_project_opendevin"
    project_path = TEST_OUTPUT_BASE_DIR / project_name
    project_path.mkdir(parents=True, exist_ok=True)  # Create a dummy project directory

    # Create a dummy app.py as if GPT-Engineer made it
    app_content = "print('hello from test_project_opendevin')"
    (project_path / "app.py").write_text(app_content, encoding="utf-8")

    success = run_opendevin_debug_loop(str(project_path))
    assert success
    assert (project_path / "tests.py").exists()
    with open(project_path / "tests.py", "r", encoding="utf-8") as f:
        content = f.read()
        assert "def test_example():" in content
        assert "assert True" in content


def test_run_opendevin_debug_loop_project_not_found():
    project_path = TEST_OUTPUT_BASE_DIR / "non_existent_project"
    success = run_opendevin_debug_loop(str(project_path))
    assert not success


def test_run_gpt_engineer_io_error_simulated(monkeypatch):
    """Test IOError during file operations in run_gpt_engineer."""
    idea_details = {"name": "IOError App", "description": "Testing IO errors."}
    output_path = TEST_OUTPUT_BASE_DIR / "io_error_app"

    # Simulate an IOError when trying to create README.md
    def mock_open_failure(*args, **kwargs):
        raise IOError("Simulated permission denied")

    monkeypatch.setattr("builtins.open", mock_open_failure)

    success = run_gpt_engineer(idea_details, str(output_path))
    assert not success
    # output_path might exist if os.makedirs succeeded before open failed.
    # Check that no files were created if that's the desired outcome post-error.
    assert not (output_path / "README.md").exists()
    assert not (output_path / "app.py").exists()


def test_run_opendevin_io_error_simulated(monkeypatch):
    """Test IOError during file operations in run_opendevin_debug_loop."""
    project_name = "opendevin_io_error"
    project_path = TEST_OUTPUT_BASE_DIR / project_name
    project_path.mkdir(parents=True, exist_ok=True)
    (project_path / "app.py").write_text("print('hello')", encoding="utf-8")

    def mock_open_failure_opendevin(*args, **kwargs):
        raise IOError("Simulated permission denied for OpenDevin test file")

    monkeypatch.setattr("builtins.open", mock_open_failure_opendevin)

    success = run_opendevin_debug_loop(str(project_path))
    assert not success
    assert not (project_path / "tests.py").exists()
